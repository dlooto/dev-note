(⊙o⊙)哦

两个方面: 
同一个人进入到他加入的不同社团, 看到的动态相关数据应该是不一样的; 
不同的人进入到加入的同一个社团,看到的动态数据也是不一样的. 

敏捷开发之我见
    我的敏捷经历
    团队状况
    团队实施敏捷的过程
    疑问与困惑

TODO：
整理生产环境搭建步骤：nginx/gunicorn等安装配置

Pinterest架构发展：
    http://blog.jobbole.com/38554/

何时选择分片？
当有几TB的数据时，应该尽快分片。
当表行数达到几十亿，索引超出内存容量，被交换到磁盘时
他们选出一个最大的表，放入单独的数据库
单个数据库耗尽了空间
然后，只能分片

分片的过渡？
* 过渡从一个特性的冻结开始。

* 确认分片该达到什么样的效果——希望尽少的执行查询以及最少数量的数据库去呈现一个页面。

* 剔除所有的MySQL join，将要做join的表格加载到一个单独的分片去做查询。

* 添加大量的缓存，基本上每个查询都需要被缓存。

* 这个步骤看起来像：

* 1 DB + Foreign Keys + Joins
* 1 DB + Denormalized + Cache
* 1 DB + Read Slaves + Cache
* Several functionally sharded DBs+Read Slaves+Cache
* ID sharded DBs + Backup slaves + cache

    * 早期的只读奴节点一直都存在问题，因为存在slave lag。读任务分配给了奴节点，然而主节点并没有做任何的备份记录，这样就像一条记录丢失。之后Pinterest使用缓存解决了这个问题。

    * Pinterest拥有后台脚本，数据库使用它来做备份。检查完整性约束、引用。

    * 用户表并不进行分片。Pinterest只是使用了一个大型的数据库，并在电子邮件和用户名上做了相关的一致性约束。如果插入重复用户，会返回失败。然后他们对分片的数据库做大量的写操作。



如果是为某对象动态添加的新属性,在访问并取用该属性值时,一定要先用以下语句作一个判断, 如下:
if hasattr(member, 'isClubLeader'):
    doXxx()


alter table t_club add column `member_count` integer NOT NULL;
alter table t_club add column `last_updated` datetime NOT NULL; 

工作概要:
参与乐学产品技术架构与设计工作;
参与服务端代码及前端部分代码编写;
参与产品技术框架与技术选型;
参与项目的部分敏捷开发流程推进工作, 辅助搭建一些开发环境与服务器环境;
参与4次技术人员面试工作.

====signals usage:
# 添加"创建活动"到个人动态
sAddEvent.send(sender=Event, owner=author, etype=Event.ACT_PUBLISH, 
    cid=act.id, linetime=act.published_time, ctitle=act.title, 
    cpic=act.poster)


########################### activity related ############################

def queryActivities(request, keywords):
    '''查询活动'''
    
    tagId = request.REQUEST.get('tagId', '')
    if tagId:
        #tag = Tag.objects.getById(int(tagId))
        tag = gdata.getTag(int(tagId))
        
    intervalType = request.REQUEST.get('intervalType', '')
    if intervalType:
        dateInterval = _getDateInterval(intervalType)
        
    return Activity.objects.searchActivities(keywords)


sAddEvent.send(sender=Event, owner=author, etype=Event.ACT_PUBLISH)

#    def popMember(self, member):
#        '''将成员降为社团普通成员,即不属于任何部门, 无任何头衔'''
#        
#        sql = '''update t_membership set joined_unit_id='', joined_unit_name='', 
#            assigned_title='' where club_id=%s and member_id=%s and relation=%s'''  
#        
#        try:    
#            db_utils.update(sql, (self.club_id, member.id, Membership.JOINED))
#            logger.debug('Execute SQL completed: %s' % sql)
#            return True
#        except Exception, e:
#            logger.error('Execute SQL failed: %s \n %s' % (sql, e))
#            return False   


module circular imports Relative Imports Absolute Imports














